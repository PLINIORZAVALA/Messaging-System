import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Credential } from '../entity/credential.entity';
import { IssuerKey } from 'src/entity/IssuerKey.entity';
import { CreateCredentialDTO } from '../dto/create-credential.dto';
import { sign } from 'crypto';

@Injectable()
export class CredentialService {
  constructor(
    @InjectRepository(Credential)
    private credentialRepository: Repository<Credential>,

    @InjectRepository(IssuerKey)
    private keyRepository: Repository<IssuerKey>,
  ) {}

  // Get all credentials
  async getAllCredentials(): Promise<Credential[]> {
    return await this.credentialRepository.find();
  }

  // Get credential by ID
  async getCredentialById(id: number): Promise<Credential> {
    const credential = await this.credentialRepository.findOne({ where: { id } });
    if (!credential) {
      throw new NotFoundException(`Credential with ID ${id} not found`);
    }
    return credential;
  }

  // Obtener la clave privada del emisor desde la base de datos
  private async getIssuerPrivateKey(): Promise<string> {
    const issuerKey = await this.keyRepository.findOne({ where: { id: 1 } });
    if (!issuerKey) {
      throw new Error('Clave del emisor no encontrada en la base de datos.');
    }
    return issuerKey.privateKey;
  }

  // Crear, firmar y guardar la credencial en la base de datos
  async createCredential(credentialData: CreateCredentialDTO): Promise<Credential> {
    const privateKey = await this.getIssuerPrivateKey();

    const credential = {
      "@context": [
        "https://www.w3.org/ns/credentials/v2",
        "https://www.w3.org/ns/credentials/examples/v2"
      ],
      "id": "http://university.example/credentials/3732",
      "type": ["VerifiableCredential", "ExampleDegreeCredential"],
      "issuer": "https://university.example/issuers/565049",
      "ValidFrom": new Date().toISOString(),
      "credentialSubject": {
        ...credentialData,  // Usa los datos de la credencial
      },
    };

    // Firma la credencial con la clave privada almacenada
    const signature = this.signWithEd25519(privateKey, JSON.stringify(credential));

    // Añadimos la firma al objeto de la credencial
    const signedCredential = {
      credential,
      proof: {
        type: "DataIntegrityProof",
        crytoduite: 'Ed25519Signature2018',
        created: new Date().toISOString(),
        verificationMethod: "https://university.example/issuers/14#key-1",
        proofPurpose: "assertionMethod",
        proofValue: signature.toString('base64'),
      },
    };

    // Crear la entidad Credential para guardar en la base de datos
    const credentialEntity = new Credential();
    credentialEntity.credential = signedCredential;

    // Guardar la credencial firmada en la base de datos
    await this.credentialRepository.save(credentialEntity);

    return credentialEntity;
  }

  // Función para firmar los datos con Ed25519
  private signWithEd25519(privateKey: string, data: string): Buffer {
    return sign(null, Buffer.from(data), privateKey);
  }
}
